<?php

class Database
{
    private static ?PDO $pdo = null;
    private const LEGACY_ADMIN_EMAIL = 'admin@example.com';
    private const LEGACY_ADMIN_HASH = '$2y$10$MxiU.PXSCpMCXEbuXdYJOuagXQkij7nThtu2RaAbu03/C14CVQRXG';
    private const INVOICE_STATUSES = ['pending', 'paid', 'overdue', 'canceled'];

    private static function credentialsFilePath(string $dbPath): string
    {
        return dirname($dbPath) . '/initial_admin_credentials.txt';
    }

    private static function randomPassword(): string
    {
        return rtrim(strtr(base64_encode(random_bytes(12)), '+/', '-_'), '=');
    }

    private static function writeCredentialsFile(string $dbPath, string $email, string $password, string $reason): void
    {
        $file = self::credentialsFilePath($dbPath);
        $content = implode(PHP_EOL, [
            'ClientPay - credenciais iniciais do administrador',
            'Data: ' . date('c'),
            'Motivo: ' . $reason,
            'Email: ' . $email,
            'Senha: ' . $password,
            '',
            'Altere a senha imediatamente após o login.',
            '',
        ]);
        file_put_contents($file, $content, LOCK_EX);
        @chmod($file, 0600);
    }

    private static function ensureBootstrapAdmin(string $dbPath): void
    {
        $count = (int)self::$pdo->query('SELECT COUNT(*) c FROM users')->fetch()['c'];
        if ($count > 0) {
            return;
        }

        $email = trim((string)(getenv('CLIENTPAY_ADMIN_EMAIL') ?: self::LEGACY_ADMIN_EMAIL));
        $name = trim((string)(getenv('CLIENTPAY_ADMIN_NAME') ?: 'Admin'));
        $password = (string)getenv('CLIENTPAY_ADMIN_PASSWORD');
        $autoGenerated = false;
        if ($password === '') {
            $password = self::randomPassword();
            $autoGenerated = true;
        }

        $hash = password_hash($password, PASSWORD_BCRYPT);
        $stm = self::$pdo->prepare('INSERT INTO users(name,email,password_hash) VALUES(?,?,?)');
        $stm->execute([$name, $email, $hash]);

        if ($autoGenerated) {
            self::writeCredentialsFile($dbPath, $email, $password, 'Bootstrap inicial do sistema');
        }
    }

    private static function hardenLegacyAdmin(string $dbPath): void
    {
        $stm = self::$pdo->prepare('SELECT id FROM users WHERE email = ? AND password_hash = ? LIMIT 1');
        $stm->execute([self::LEGACY_ADMIN_EMAIL, self::LEGACY_ADMIN_HASH]);
        $admin = $stm->fetch();
        if (!$admin) {
            return;
        }

        $password = (string)getenv('CLIENTPAY_ADMIN_PASSWORD');
        $autoGenerated = false;
        if ($password === '') {
            $password = self::randomPassword();
            $autoGenerated = true;
        }
        $hash = password_hash($password, PASSWORD_BCRYPT);
        $upd = self::$pdo->prepare('UPDATE users SET password_hash = ? WHERE id = ?');
        $upd->execute([$hash, (int)$admin['id']]);

        if ($autoGenerated) {
            self::writeCredentialsFile($dbPath, self::LEGACY_ADMIN_EMAIL, $password, 'Rotação automática de senha padrão insegura');
        }
    }

    private static function quoteIdentifier(string $identifier): string
    {
        if (!preg_match('/^[A-Za-z_][A-Za-z0-9_]*$/', $identifier)) {
            throw new InvalidArgumentException('Identificador SQL inválido.');
        }
        return '"' . $identifier . '"';
    }

    private static function tableExists(string $table): bool
    {
        $stm = self::$pdo->prepare("SELECT 1 FROM sqlite_master WHERE type='table' AND name=? LIMIT 1");
        $stm->execute([$table]);
        return (bool)$stm->fetchColumn();
    }

    private static function columnExists(string $table, string $column): bool
    {
        if (!self::tableExists($table)) {
            return false;
        }
        $sql = 'PRAGMA table_info(' . self::quoteIdentifier($table) . ')';
        $cols = self::$pdo->query($sql)->fetchAll();
        foreach ($cols as $col) {
            if (isset($col['name']) && strcasecmp((string)$col['name'], $column) === 0) {
                return true;
            }
        }
        return false;
    }

    private static function indexExists(string $indexName): bool
    {
        $stm = self::$pdo->prepare("SELECT 1 FROM sqlite_master WHERE type='index' AND name=? LIMIT 1");
        $stm->execute([$indexName]);
        return (bool)$stm->fetchColumn();
    }

    private static function ensureColumn(string $table, string $column, string $definition, ?string $backfillSql = null): void
    {
        if (!self::tableExists($table) || self::columnExists($table, $column)) {
            return;
        }

        $sql = sprintf(
            'ALTER TABLE %s ADD COLUMN %s %s',
            self::quoteIdentifier($table),
            self::quoteIdentifier($column),
            $definition
        );
        self::$pdo->exec($sql);

        if ($backfillSql) {
            self::$pdo->exec($backfillSql);
        }
    }

    private static function ensureMigrationsTable(): void
    {
        self::$pdo->exec(
            "CREATE TABLE IF NOT EXISTS schema_migrations (
                version INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                applied_at TEXT NOT NULL DEFAULT (DATETIME('now'))
            )"
        );
    }

    private static function hasMigration(int $version): bool
    {
        $stm = self::$pdo->prepare('SELECT 1 FROM schema_migrations WHERE version = ? LIMIT 1');
        $stm->execute([$version]);
        return (bool)$stm->fetchColumn();
    }

    private static function markMigration(int $version, string $name): void
    {
        $stm = self::$pdo->prepare('INSERT INTO schema_migrations(version, name) VALUES(?, ?)');
        $stm->execute([$version, $name]);
    }

    private static function runMigrations(): void
    {
        self::ensureMigrationsTable();

        $migrations = [
            2026022701 => [
                'name' => 'add_missing_columns_for_legacy_databases',
                'up' => static function (): void {
                    self::ensureColumn('users', 'created_at', 'TEXT', "UPDATE users SET created_at = DATETIME('now') WHERE created_at IS NULL");

                    self::ensureColumn('clients', 'email', 'TEXT');
                    self::ensureColumn('clients', 'whatsapp', 'TEXT');
                    self::ensureColumn('clients', 'created_at', 'TEXT', "UPDATE clients SET created_at = DATETIME('now') WHERE created_at IS NULL");
                    self::ensureColumn('clients', 'updated_at', 'TEXT', "UPDATE clients SET updated_at = DATETIME('now') WHERE updated_at IS NULL");

                    self::ensureColumn('sites', 'domain', 'TEXT');
                    self::ensureColumn('sites', 'creation_cost', 'REAL NOT NULL DEFAULT 0');
                    self::ensureColumn('sites', 'current_monthly_fee', 'REAL NOT NULL DEFAULT 0');
                    self::ensureColumn('sites', 'created_at', 'TEXT', "UPDATE sites SET created_at = DATETIME('now') WHERE created_at IS NULL");
                    self::ensureColumn('sites', 'updated_at', 'TEXT', "UPDATE sites SET updated_at = DATETIME('now') WHERE updated_at IS NULL");

                    self::ensureColumn('plan_history', 'notes', 'TEXT');
                    self::ensureColumn('plan_history', 'created_at', 'TEXT', "UPDATE plan_history SET created_at = DATETIME('now') WHERE created_at IS NULL");

                    self::ensureColumn('invoices', 'status', "TEXT NOT NULL DEFAULT 'pending'");
                    self::ensureColumn('invoices', 'notes', 'TEXT');
                    self::ensureColumn('invoices', 'created_at', 'TEXT', "UPDATE invoices SET created_at = DATETIME('now') WHERE created_at IS NULL");
                    self::ensureColumn('invoices', 'updated_at', 'TEXT', "UPDATE invoices SET updated_at = DATETIME('now') WHERE updated_at IS NULL");

                    self::ensureColumn('templates', 'active', 'INTEGER NOT NULL DEFAULT 1');
                    self::ensureColumn('templates', 'updated_at', 'TEXT', "UPDATE templates SET updated_at = DATETIME('now') WHERE updated_at IS NULL");
                },
            ],
            2026022702 => [
                'name' => 'normalize_invoices_and_indexes',
                'up' => static function (): void {
                    if (self::tableExists('invoices')) {
                        $statuses = "'" . implode("','", self::INVOICE_STATUSES) . "'";
                        self::$pdo->exec("UPDATE invoices SET status='pending' WHERE status IS NULL OR TRIM(status)=''");
                        self::$pdo->exec("UPDATE invoices SET status='pending' WHERE status NOT IN ($statuses)");
                    }

                    if (!self::indexExists('idx_invoices_site_due_date') && self::tableExists('invoices')) {
                        try {
                            self::$pdo->exec('CREATE UNIQUE INDEX IF NOT EXISTS idx_invoices_site_due_date ON invoices(site_id, due_date)');
                        } catch (PDOException $e) {
                            // Base legada pode conter duplicidades de site/data. Preserva dados e cria índice não-único.
                            if (!self::indexExists('idx_invoices_site_due_date_lookup')) {
                                self::$pdo->exec('CREATE INDEX IF NOT EXISTS idx_invoices_site_due_date_lookup ON invoices(site_id, due_date)');
                            }
                        }
                    }
                },
            ],
        ];

        foreach ($migrations as $version => $migration) {
            if (self::hasMigration($version)) {
                continue;
            }

            self::$pdo->beginTransaction();
            try {
                $up = $migration['up'];
                $up();
                self::markMigration($version, (string)$migration['name']);
                self::$pdo->commit();
            } catch (Throwable $e) {
                if (self::$pdo->inTransaction()) {
                    self::$pdo->rollBack();
                }
                throw $e;
            }
        }
    }

    public static function init(array $cfg): void
    {
        if (self::$pdo) return;
        $dbPath = $cfg['db']['path'];
        $dir = dirname($dbPath);
        if (!is_dir($dir)) mkdir($dir, 0777, true);
        $isNew = !file_exists($dbPath);

        self::$pdo = new PDO('sqlite:' . $dbPath, null, null, [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_PERSISTENT => false,
        ]);
        self::$pdo->exec('PRAGMA foreign_keys = ON');

        if ($isNew) {
            $schema = file_get_contents($cfg['db']['sql']);
            self::$pdo->exec($schema);
        }

        self::runMigrations();
        self::ensureBootstrapAdmin($dbPath);
        self::hardenLegacyAdmin($dbPath);
    }

    public static function pdo(): PDO
    {
        return self::$pdo;
    }
}
